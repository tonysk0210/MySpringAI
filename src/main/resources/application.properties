spring.application.name=MySpringAi
# Log formate: green = 時間 / blue = log等級 / red = thread名稱 / yellow = log名稱 / white = log內容
logging.pattern.console=%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%logger{15}) - %msg%n
# OpenAI-model type
spring.ai.openai.api-key=${OPENAI_API_KEY}
spring.ai.openai.chat.options.model=gpt-4.1-nano
# Ollama-model type
spring.ai.ollama.chat.options.model=llama3.2:1b
# Enable DEBUG logging for SimpleLoggerAdvisor
logging.level.org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor=DEBUG
# AUTO_SERVER=true 多個連線同時存取同一個 H2 檔案 Spring Boot app + H2 Console + DataGrip
spring.datasource.url=jdbc:h2:file:.\\chatmemory;AUTO_SERVER=true
spring.datasource.driver-class-name=org.h2.Driver
# 啟用 H2 Console
spring.h2.console.enabled=true
# 讓 Spring AI「自動執行內建 schema-h2.sql（或其他 dialect schema）」來建立資料表
spring.ai.chat.memory.repository.jdbc.initialize-schema=embedded
# 因為 Qdrant 是用 Spring Boot 自動啟動的，如果不用 down， container 會殘留，導致：佔用 port（6333/6334）
spring.docker.compose.stop.command=down
# 當 Spring Boot 啟動時，若 Qdrant 的 collection 不存在，就會「自動建立 schema」
spring.ai.vectorstore.qdrant.initialize-schema=true
# Spring AI 要連線的 Qdrant 主機名稱
spring.ai.vectorstore.qdrant.host=localhost
# 所以 Spring AI 用 gRPC client 去連 Qdrant
spring.ai.vectorstore.qdrant.port=6334
# 我希望所有 RAG 的向量資料都存進 Qdrant 的 rag-collection 這個 collection，同一個 Qdrant 伺服器可以給很多模型用，但每個模型必須用自己的 Collection（向量維度必須一致）。
spring.ai.vectorstore.qdrant.collection-name=rag-collection

